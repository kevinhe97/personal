<script>
/**
🔚
@file end-from-dialog
@summary trigger an ending from dialog, including narration text
@license WTFPL (do WTF you want)
@version 3.3.3
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
Lets you end the game from dialog (including inside conditionals).

Using the (end) function in any part of a series of dialog will make the
game end after the dialog is finished. Ending the game resets it back to the
intro.

If the text provided as an argument is a valid ending id,
the corresponding ending text will be shown.
If not, the text provided will be used directly as ending text.

Using (endNow) at the end of a sentence will display the whole sentence and
immediately clear the background. No further dialog from that passage will
display, and the game will reset when you proceed. Using (endNow) with
narration text will immediately exit the dialog, clear the background, and
show the ending narration in an ending-style centered dialog box.

Usage: (end)
       (end "<ending id>")
       (end "<ending narration>")
       (endNow)
       (endNow "<ending id>")
       (endNow "<ending narration>")

Example: (end)
         (end "Five friars bid you goodbye. You leave the temple, hopeful.")
         (endNow "The computer is still online! The chamber floods with neurotoxin.")

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
  var kitsy = kitsyInit();
  kitsy.queuedInjectScripts.push({
    searchRegex: searchRegex,
    replaceString: replaceString
  });
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
  var kitsy = kitsyInit();
  kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
  kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
  var kitsy = kitsyInit();
  kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
  kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
  return input
    .replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function(match, group){
      if(match.substr(0,1) === '\\') {
        return '('+ group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
      }
      return '{'+ group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
    });
}


function addDialogFunction(tag, fn) {
  var kitsy = kitsyInit();
  kitsy.dialogFunctions = kitsy.dialogFunctions || {};
  if (kitsy.dialogFunctions[tag]) {
    throw new Error('The dialog function "' + tag + '" already exists.');
  }

  // Hook into game load and rewrite custom functions in game data to Bitsy format.
  before('parseWorld', function (game_data) {
    return [convertDialogTags(game_data, tag)];
  });

  kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
  addDialogFunction(tag, fn);
  inject$1(
    /(var functionMap = new Map\(\);)/,
    '$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
  );
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
  addDialogFunction(tag, fn);
  bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
  var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
  inject$1(
    /(var functionMap = new Map\(\);)/,
    '$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
  );
  // Hook into the dialog finish event and execute the actual function
  after('onExitDialog', function () {
    while (deferred.length) {
      var args = deferred.shift();
      bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
    }
  });
  // Hook into the game reset and make sure data gets cleared
  after('clearGameData', function () {
    deferred.length = 0;
  });
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
  addDialogTag(tag + 'Now', function(environment, parameters, onReturn) {
    fn(environment, parameters);
    onReturn(null);
  });
  addDeferredDialogTag(tag, fn);
}



// Implement the dialog functions
addDualDialogTag('end', function (environment, parameters) {
  bitsy.dialogBuffer.EndDialog();
  bitsy.startNarrating(bitsy.ending[parameters[0]] || parameters[0] || '', true);
});
// End of (end) dialog function mod

}(window));

  /**
🚪
@file exit-from-dialog
@summary exit to another room from dialog, including conditionals
@license WTFPL (do WTF you want)
@version 7.0.2
@requires Bitsy Version: 6.0
@author @mildmojo

@description
Lets you exit to another room from dialog (including inside conditionals).
Use it to make an invisible sprite that acts as a conditional exit, use it to warp
somewhere after a conversation, use it to put a guard at your gate who only
lets you in once you're disguised, use it to require payment before the
ferryman will take you across the river.

Using the (exit) function in any part of a series of dialog will make the
game exit to the new room after the dialog is finished. Using (exitNow) will
immediately warp to the new room, but the current dialog will continue.

Usage:
  (exit "<room name>,<x>,<y>,<transition_effect>")
  (exitNow "<room name>,<x>,<y>,<transition_effect>")

Parameter notes:
  - Every paramater is optional
  - If you omit the room, it will use the current room
  - If you omit the x or y, it will use the current position
  - x and y can be written as relative coordinates (e.g. +3, -4, +0)
  - available transitions at time of writing: fade_w, fade_b, wave, tunnel, slide_u, slide_d, slide_l, slide_r

Examples:
  (exit "FinalRoom,8,4")
  (exit "FinalRoom,8,4,tunnel")
  (exit "FinalRoom")
  (exit "FinalRoom,+0,+0,tunnel")
  (exit ",+1,+1")

HOW TO USE:
1. Copy-paste this script into a new script tag after the Bitsy source code.
   It should appear *before* any other mods that handle loading your game
   data so it executes *after* them (last-in first-out).

NOTE:
This uses parentheses "()" instead of curly braces "{}" around function
calls because the Bitsy editor's fancy dialog window strips unrecognized
curly-brace functions from dialog text. To keep from losing data, write
these function calls with parentheses like the examples above.
*/
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting room by name or id
 * @param {string} name id or name of room to return
 * @return {string} room, or undefined if it doesn't exist
 */
function getRoom(name) {
  var id = Object.prototype.hasOwnProperty.call(bitsy.room, name) ? name : bitsy.names.room.get(name);
  return bitsy.room[id];
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
  var kitsy = kitsyInit();
  kitsy.queuedInjectScripts.push({
    searchRegex: searchRegex,
    replaceString: replaceString
  });
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
  var kitsy = kitsyInit();
  kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
  kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
  var kitsy = kitsyInit();
  kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
  kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
  return input
    .replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function(match, group){
      if(match.substr(0,1) === '\\') {
        return '('+ group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
      }
      return '{'+ group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
    });
}


function addDialogFunction(tag, fn) {
  var kitsy = kitsyInit();
  kitsy.dialogFunctions = kitsy.dialogFunctions || {};
  if (kitsy.dialogFunctions[tag]) {
    throw new Error('The dialog function "' + tag + '" already exists.');
  }

  // Hook into game load and rewrite custom functions in game data to Bitsy format.
  before('parseWorld', function (game_data) {
    return [convertDialogTags(game_data, tag)];
  });

  kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
  addDialogFunction(tag, fn);
  inject$1(
    /(var functionMap = new Map\(\);)/,
    '$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
  );
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
  addDialogFunction(tag, fn);
  bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
  var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
  inject$1(
    /(var functionMap = new Map\(\);)/,
    '$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
  );
  // Hook into the dialog finish event and execute the actual function
  after('onExitDialog', function () {
    while (deferred.length) {
      var args = deferred.shift();
      bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
    }
  });
  // Hook into the game reset and make sure data gets cleared
  after('clearGameData', function () {
    deferred.length = 0;
  });
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
  addDialogTag(tag + 'Now', function(environment, parameters, onReturn) {
    fn(environment, parameters);
    onReturn(null);
  });
  addDeferredDialogTag(tag, fn);
}



// Implement the dialog functions
addDualDialogTag('exit', function (environment, parameters) {
  var exit = getExitParams(parameters);
  if (!exit) {
    return;
  }
  bitsy.movePlayerThroughExit(exit);
});

function getExitParams(parameters) {
  var p = bitsy.player();
  var params = parameters[0].split(',');
  var roomName = params[0];
  var x = params[1];
  var y = params[2];
  var transition_effect = params[3];
  var room = getRoom(roomName);

  if (!room) {
    room = bitsy.room[p.room];
  }

  if (!x) {
    x = p.x;
  } else if (x.startsWith('+') || x.startsWith('-')) {
    x = p.x + Number(x);
  } else {
    x = Number(x);
  }

  if (!y) {
    y = p.y;
  } else if (y.startsWith('+') || y.startsWith('-')) {
    y = p.y + Number(y);
  } else {
    y = Number(y);
  }

  return {
    dest: {
      room: room.id,
      x,
      y,
    },
    transition_effect,
  };
}
// End of (exit) dialog function mod

}(window));
</script>
<script>
  /**
🏃
@file smooth moves
@summary ease the player's movement
@license MIT
@version 2.0.0
@requires Bitsy Version: 6.3
@author Sean S. LeBlanc

@description
Makes the player avatar ease in between positions instead of moving immediately.
Speed and easing function are configurable.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
  // duration of ease in ms
  duration: 100,
  // max distance to allow tweens
  delta: 1.5,
  // easing function
  ease: function(t) {
    t = 1 - Math.pow(1 - t, 2);
    return t;
  },
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
  var kitsy = kitsyInit();
  kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
  kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
  var kitsy = kitsyInit();
  kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
  kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





// smooth move
var tweens = {};
var sprites = {};
function addTween(spr, fromX, fromY, toX, toY) {
  if (Math.abs(toX - fromX) + Math.abs(toY - fromY) > hackOptions.delta) {
    delete tweens[spr];
  } else {
    var t = tweens[spr] = tweens[spr] || {};
    t.fromX = fromX;
    t.fromY = fromY;
    t.toX = toX;
    t.toY = toY;
    t.start = bitsy.prevTime;
  }
}
before('onready', function() {
  tweens = {};
  sprites = {};
});

// listen for changes in sprite positions to add tweens
before('update', function() {
  Object.values(bitsy.sprite).forEach(spr => {
    if (spr.room === bitsy.curRoom) {
      var s = sprites[spr.id] = sprites[spr.id] || {};
      s.x = spr.x;
      s.y = spr.y;
    } else {
      delete sprites[spr.id];
    }
  });
});
function addTweens() {
  Object.entries(sprites).forEach(function (entry) {
    var spr = bitsy.sprite[entry[0]];
    var pos = entry[1];
    if (pos.x !== spr.x || pos.y !== spr.y) {
      addTween(spr.id, pos.x, pos.y, spr.x, spr.y);
    }
  });
}
after('updateInput', addTweens);
after('update', addTweens);
// before drawing, update sprite positions to tweened values
before('drawRoom', function () {
  Object.entries(tweens).forEach(function (entry) {
    var tween = entry[1];
    var t = hackOptions.ease(Math.min(1, (bitsy.prevTime - tween.start) / hackOptions.duration));
    var sprite = bitsy.sprite[entry[0]];
    sprite.x = tween.fromX + (tween.toX - tween.fromX) * t;
    sprite.y = tween.fromY + (tween.toY - tween.fromY) * t;
  });
});
// after drawing, update sprite positions back to normal
after('drawRoom', function () {
  Object.entries(tweens).forEach(function (entry) {
    var tween = entry[1];
    var sprite = bitsy.sprite[entry[0]];
    sprite.x = tween.toX;
    sprite.y = tween.toY;
  });
});

exports.hackOptions = hackOptions;

}(this.hacks.smooth_moves = this.hacks.smooth_moves || {}, window));
</script>
<script>
  /**
🔁
@file dialog box transition
@summary adds an easing transition animation to display the dialog box text
@license MIT
@version 1.0.2
@requires 4.8, 4.9
@author Delacannon

@description
A hack that adds an easing transition animation to display the dialog box text

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source.
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
  easing: 0.075 //  easing speed
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
  var kitsy = kitsyInit();
  kitsy.queuedInjectScripts.push({
    searchRegex: searchRegex,
    replaceString: replaceString
  });
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





var drawOverride = `
if(context == null) return;
    if (isCentered) {
      context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
      this.onExit = ((height/2)-(textboxInfo.height/2))*scale === ((height/2)-(textboxInfo.height/2))*scale
    }
    else if (player().y < mapsize/2) {
      easingDialog(textboxInfo, ${hackOptions.easing}, 
        !this.onClose ? (height-textboxInfo.bottom-textboxInfo.height)*scale
        : (height+textboxInfo.bottom+textboxInfo.height)*scale
         ) 
      this.onExit = this.onClose && textboxInfo.y >= (height+textboxInfo.height)*scale
    }
    else {
      easingDialog(textboxInfo, ${
        hackOptions.easing
      }, !this.onClose ? textboxInfo.top*scale : 
        -textboxInfo.top-textboxInfo.height*scale) 
       this.onExit = this.onClose && textboxInfo.y <= -textboxInfo.height*scale
    }
return;`;

var functionEasing = `
  function easingDialog(tbox, easing, targetY) {
    var vy = (targetY - tbox.y) * easing;
    tbox.y += vy;
    context.putImageData(tbox.img,tbox.left*scale,tbox.y);
  }
  this.onClose = false;
  this.onExit = false;
`;

inject$1(
  /(this\.DrawTextbox\(\))/,
  `$1\nif(this.onExit && this.onClose){dialogBuffer.EndDialog()}`
);
inject$1(/(this\.EndDialog\(\))/, `dialogRenderer.onClose=true`);
inject$1(/(var DialogRenderer = function\(\) {)/, `$1${functionEasing}`);
inject$1(/(var textboxInfo = {)/, `$1y:0,`);
inject$1(
  /(this\.Reset = function\(\) {)/,
  `$1 this.onClose=false;
    this.onExit=false;
    textboxInfo.y = player().y < mapsize/2 ? (height+textboxInfo.bottom+textboxInfo.height)*scale : -(textboxInfo.height) * scale;`
);

inject$1(/(this\.DrawTextbox = function\(\) {)/, `$1${drawOverride}`);

exports.hackOptions = hackOptions;

}(this.hacks.dialog_box_transition = this.hacks.dialog_box_transition || {}, window));
</script>
<script>
  /**
🏁
@file transparent sprites
@summary makes all sprites have transparent backgrounds
@license MIT
@version 4.0.4
@requires Bitsy Version: 6.1
@author Sean S. LeBlanc

@description
Makes all sprites have transparent backgrounds.
i.e. tiles can be seen underneath the player, sprites, and items.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
  isTransparent: function (drawing) {
    //return drawing.name == 'tea'; // specific transparent drawing
    //return ['tea', 'flower', 'hat'].indexOf(drawing.name) !== -1; // specific transparent drawing list
    //return drawing.name && drawing.name.indexOf('TRANSPARENT') !== -1; // transparent drawing flag in name
    //return ['bed1A', 'bed1B', 'wash', 'grillA', 'grillB', 'cardboard', 'bear', 'light', 'hand', 'eyes']; // all drawings are transparent
    return true;
  },
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
  var kitsy = kitsyInit();
  kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
  kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





var madeTransparent;
var makeTransparent;
before('onready', function() {
  madeTransparent = {};
  makeTransparent = false;
});
before('renderer.GetImage', function (drawing, paletteId, frameOverride) {
  // check cache first
  var cache = madeTransparent[drawing.drw] = madeTransparent[drawing.drw] || {};
  var p = cache[paletteId] = cache[paletteId] || {};
  var frameIndex = frameOverride || drawing.animation.frameIndex;
  var source = bitsy.renderer.GetImageSource(drawing.drw);
  if (p[frameIndex] === source) {
    // already made this transparent
    return;
  }

  // flag the next draw as needing to be made transparent
  p[frameIndex] = source;
  makeTransparent = hackOptions.isTransparent(drawing);
});

before('drawTile', function (canvas) {
  if (makeTransparent) {
    // redraw with all bg pixels transparent
    var ctx = canvas.getContext('2d');
    var data = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var bg = bitsy.getPal(bitsy.getRoomPal(bitsy.player().room))[0];
    for (let i = 0; i < data.data.length; i += 4) {
      var r = data.data[i];
      var g = data.data[i + 1];
      var b = data.data[i + 2];
      if (r === bg[0] && g === bg[1] && b === bg[2]) {
        data.data[i + 3] = 0;
      }
    }
    ctx.putImageData(data, 0, 0);
    // clear the flag
    makeTransparent = false;
  }
});

exports.hackOptions = hackOptions;

}(this.hacks.transparent_sprites = this.hacks.transparent_sprites || {}, window));

</script>
<script>

/**
❄
@file unique items
@summary items which, when picked up, remove all other instances of that item from the game
@license MIT
@version 2.0.4
@author Sean S. LeBlanc

@description
Adds support for items which, when picked up,
remove all other instances of that item from the game.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Update the `itemIsUnique` function to match your needs
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
  itemIsUnique: function (item) {
    //return item.name && item.name == 'tea'; // specific unique item
    //return ['tea', 'flower', 'hat'].indexOf(item.name) !== -1; // specific unique item list
    //return item.name && item.name.indexOf('UNIQUE') !== -1; // unique item flag in name
    //return true; // all items are unique
    return ['1', '2', '3', '4', 'confusion']
  }
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
  var kitsy = kitsyInit();
  kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
  kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





after('onInventoryChanged', function (id) {
  var r;
  if (hackOptions.itemIsUnique(bitsy.item[id])) {
    for (r in bitsy.room) {
      if (Object.prototype.hasOwnProperty.call(bitsy.room, r)) {
        r = bitsy.room[r];
        r.items = r.items.filter(function (i) {
          return i.id !== id;
        });
      }
    }
  }
});

exports.hackOptions = hackOptions;

}(this.hacks.unique_items = this.hacks.unique_items || {}, window));

</script>
<script>

/**
😌
@file bitsymuse
@summary A variety of Bitsy sound and music handlers
@license MIT
@version 3.0.5
@requires 4.8, 4.9
@author David Mowatt

@description
A hack that adds a variety of audio controls, including music that changes as you move between rooms.
If the same song is played as you move between rooms, the audio file will continue playing.

HOW TO USE:
1. Place your audio files somewhere relative to your bitsy html file (in the zip if you're uploading to itch.io)
2. Copy-paste `<audio id="sound ID" src="relative path to sound file"></audio>` into the <head> of your document.
   You need to do it once for each sound file you are adding, and each needs a unique sound ID. Add `loop` after the `src=""`
   tag if it's music that's going to loop (e.g. `<audio id="sound ID" src="./mySong.mp3" loop></audio>`)
3. Copy-paste this script into a script tag after the bitsy source.
4. Edit hackOptions below to set up the TRACK LIST for rooms you move through.

In addition to the track list, which will play audio based on the room number/name,
you have access to the following commands you can add to dialogue:

1. (soundeffectNow "<sound ID>") will play a sound without interrupting the music as soon as it is called in the dialogue
2. (soundeffect "<sound ID>") will play a sound without interrupting the music once the dialogue box closes
3. (musicNow "<sound ID>") will change the music as soon as it is called in the dialogue
4. (music "<sound ID>") will change the music once the dialogue box closes

You can call both musicNow and music in the same dialogue, to e.g. change the music while you speak to a character
and then restart the regular room music once you stop speaking to them.
You can also use a special ID ("S" by default) to Silence the music.

By default, music tracks automatically restart from the beginning if you go back to a previous track.
This can also be changed in the hackOptions below.
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
  // You need to put an entry in this list for every room ID or name that is accessible by the player,
  // and then specify the song ID for each room. Expand this list to as many rooms as you need.
  // If the player moves between rooms with the same audio ID the music keeps playing seamlessly.
  // Undefined rooms will keep playing whatever music they were last playing
  musicByRoom: {
    // Note: the entries below are examples that should be removed and replaced with your own room -> audio id mappings
    bedroom: 'littleroot',
    yard: 'S',
  },
  silenceId: 'S', // Use this song ID of to make a room fall silent.
  resume: false, // If true, songs will pause/resume on change; otherwise, they'll stop/play (doesn't affect sound effects)
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting room by name or id
 * @param {string} name id or name of room to return
 * @return {string} room, or undefined if it doesn't exist
 */
function getRoom(name) {
  var id = Object.prototype.hasOwnProperty.call(bitsy.room, name) ? name : bitsy.names.room.get(name);
  return bitsy.room[id];
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
  var kitsy = kitsyInit();
  kitsy.queuedInjectScripts.push({
    searchRegex: searchRegex,
    replaceString: replaceString
  });
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
  var kitsy = kitsyInit();
  kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
  kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
  var kitsy = kitsyInit();
  kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
  kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
  return input
    .replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function(match, group){
      if(match.substr(0,1) === '\\') {
        return '('+ group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
      }
      return '{'+ group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
    });
}


function addDialogFunction(tag, fn) {
  var kitsy = kitsyInit();
  kitsy.dialogFunctions = kitsy.dialogFunctions || {};
  if (kitsy.dialogFunctions[tag]) {
    throw new Error('The dialog function "' + tag + '" already exists.');
  }

  // Hook into game load and rewrite custom functions in game data to Bitsy format.
  before('parseWorld', function (game_data) {
    return [convertDialogTags(game_data, tag)];
  });

  kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
  addDialogFunction(tag, fn);
  inject$1(
    /(var functionMap = new Map\(\);)/,
    '$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
  );
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
  addDialogFunction(tag, fn);
  bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
  var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
  inject$1(
    /(var functionMap = new Map\(\);)/,
    '$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
  );
  // Hook into the dialog finish event and execute the actual function
  after('onExitDialog', function () {
    while (deferred.length) {
      var args = deferred.shift();
      bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
    }
  });
  // Hook into the game reset and make sure data gets cleared
  after('clearGameData', function () {
    deferred.length = 0;
  });
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
  addDialogTag(tag + 'Now', function(environment, parameters, onReturn) {
    fn(environment, parameters);
    onReturn(null);
  });
  addDeferredDialogTag(tag, fn);
}





var currentMusic;
var roomMusicFlag = null;

// expand the map to include ids of rooms listed by name
after('load_game', function () {
  var room;
  for (var i in hackOptions.musicByRoom) {
    if (Object.prototype.hasOwnProperty.call(hackOptions.musicByRoom, i)) {
      room = getRoom(i);
      if (room) {
        hackOptions.musicByRoom[room.id] = hackOptions.musicByRoom[i];
      }
    }
  }
});

var audioCache = {};

function getAudio(id) {
  var el = audioCache[id] || (audioCache[id] = document.getElementById(id));
  if (!el) {
    throw new Error("bitsymuse tried to use audio with id '" + id + "' but couldn't find one on the page!");
  }
  return el;
}

function playSound(soundParam) {
  if (!soundParam) {
    return;
  }
  getAudio(soundParam).play();
}

function changeMusic(newMusic) {
  var audio;
  // if we didn't get new music,
  // or the music didn't change,
  // there's no work to be done
  if (!newMusic || newMusic === currentMusic) {
    return;
  }

  // stop old music
  if (currentMusic && currentMusic !== hackOptions.silenceId) {
    audio = getAudio(currentMusic);
    audio.pause();
    if (!hackOptions.resume) {
      audio.currentTime = 0.0;
    }
  }

  // start new music
  currentMusic = newMusic;
  // special case: don't start anything new
  if (newMusic === hackOptions.silenceId) {
    return;
  }
  getAudio(newMusic).play();
}

after('drawRoom', function () {
  if (roomMusicFlag !== bitsy.curRoom) {
    changeMusic(hackOptions.musicByRoom[bitsy.curRoom]);
    roomMusicFlag = bitsy.curRoom;
  }
});

// Implement the dialog functions
addDualDialogTag('music', function (environment, parameters) {
  if (!parameters[0]) {
    throw new Error('{music/musicNow} was missing parameters! Usage: {music/musicNow "track name"}');
  }
  changeMusic(parameters[0]);
});

addDualDialogTag('soundeffect', function (environment, parameters) {
  if (!parameters[0]) {
    throw new Error('{soundeffect/soundeffectNow} was missing parameters! Usage: {soundeffect/soundeffectNow "track name"}');
  }
  playSound(parameters[0]);
});
// End of (music) dialog function mod

exports.hackOptions = hackOptions;

}(this.hacks.bitsymuse = this.hacks.bitsymuse || {}, window));

</script>
<script>

/**
📜
@file long dialog
@summary put more words onscreen
@license MIT
@version 1.1.2
@requires Bitsy Version: 6.1
@author Sean S. LeBlanc
@description
Makes the dialog box variable in height, allowing it to expand as needed.
Minimum and maximum size are configurable.
Cheat sheet:
  2: bitsy default
  8: reaches just below the halfway mark
  16: roughly the max of the original bitsy margins
  19: max before cutting off text
Note: this hack also includes the paragraph break hack
A common pattern in bitsy is using intentional whitespace to force new dialog pages,
but the long dialog hack makes that look awkward since the text box expands.
The paragraph break hack lets you get around this by using a (p) tag to immediately end the current page.
HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
  2. edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
  minRows: 2,
  maxRows: 4,
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
  inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
  // find the relevant script tag
  var scriptTags = document.getElementsByTagName('script');
  var scriptTag;
  var code;
  for (var i = 0; i < scriptTags.length; ++i) {
    scriptTag = scriptTags[i];
    var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
    var isCurrentScript = scriptTag === document.currentScript;
    if (matchesSearch && !isCurrentScript) {
      code = scriptTag.textContent;
      break;
    }
  }

  // error-handling
  if (!code) {
    throw 'Couldn\'t find "' + searchRegex + '" in script tags';
  }

  // modify the content
  code = code.replace(searchRegex, replaceString);

  // replace the old script tag with a new one using our modified code
  var newScriptTag = document.createElement('script');
  newScriptTag.textContent = code;
  scriptTag.insertAdjacentElement('afterend', newScriptTag);
  scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
  return array.filter(function (item, idx) {
    return array.indexOf(item) === idx;
  });
}

/**
@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo
@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";
  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);
  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
  var kitsy = kitsyInit();
  kitsy.queuedInjectScripts.push({
    searchRegex: searchRegex,
    replaceString: replaceString
  });
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
  var kitsy = kitsyInit();
  kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
  kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

function kitsyInit() {
  // return already-initialized kitsy
  if (bitsy.kitsy) {
    return bitsy.kitsy;
  }

  // Initialize kitsy
  bitsy.kitsy = {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {}
  };

  var oldStartFunc = bitsy.startExportedGame;
  bitsy.startExportedGame = function doAllInjections() {
    // Only do this once.
    bitsy.startExportedGame = oldStartFunc;

    // Rewrite scripts and hook everything up.
    doInjects();
    applyAllHooks();

    // Start the game
    bitsy.startExportedGame.apply(this, arguments);
  };

  return bitsy.kitsy;
}


function doInjects() {
  bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
    inject(injectScript.searchRegex, injectScript.replaceString);
  });
  _reinitEngine();
}

function applyAllHooks() {
  var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
  allHooks.forEach(applyHook);
}

function applyHook(functionName) {
  var functionNameSegments = functionName.split('.');
  var obj = bitsy;
  while (functionNameSegments.length > 1) {
    obj = obj[functionNameSegments.shift()];
  }
  var lastSegment = functionNameSegments[0];
  var superFn = obj[lastSegment];
  var superFnLength = superFn ? superFn.length : 0;
  var functions = [];
  // start with befores
  functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
  // then original
  if (superFn) {
    functions.push(superFn);
  }
  // then afters
  functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

  // overwrite original with one which will call each in order
  obj[lastSegment] = function () {
    var returnVal;
    var args = [].slice.call(arguments);
    var i = 0;

    function runBefore() {
      // All outta functions? Finish
      if (i === functions.length) {
        return returnVal;
      }

      // Update args if provided.
      if (arguments.length > 0) {
        args = [].slice.call(arguments);
      }

      if (functions[i].length > superFnLength) {
        // Assume funcs that accept more args than the original are
        // async and accept a callback as an additional argument.
        return functions[i++].apply(this, args.concat(runBefore.bind(this)));
      } else {
        // run synchronously
        returnVal = functions[i++].apply(this, args);
        if (returnVal && returnVal.length) {
          args = returnVal;
        }
        return runBefore.apply(this, args);
      }
    }

    return runBefore.apply(this, arguments);
  };
}

function _reinitEngine() {
  // recreate the script and dialog objects so that they'll be
  // referencing the code with injections instead of the original
  bitsy.scriptModule = new bitsy.Script();
  bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

  bitsy.dialogModule = new bitsy.Dialog();
  bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
  bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
  return input
    .replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function(match, group){
      if(match.substr(0,1) === '\\') {
        return '('+ group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
      }
      return '{'+ group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
    });
}


function addDialogFunction(tag, fn) {
  var kitsy = kitsyInit();
  kitsy.dialogFunctions = kitsy.dialogFunctions || {};
  if (kitsy.dialogFunctions[tag]) {
    throw new Error('The dialog function "' + tag + '" already exists.');
  }

  // Hook into game load and rewrite custom functions in game data to Bitsy format.
  before('parseWorld', function (game_data) {
    return [convertDialogTags(game_data, tag)];
  });

  kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
  addDialogFunction(tag, fn);
  inject$1(
    /(var functionMap = new Map\(\);)/,
    '$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
  );
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject$1(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');


/**
📃
@file paragraph-break
@summary Adds paragraph breaks to the dialogue parser
@license WTFPL (do WTF you want)
@version 1.1.4
@requires Bitsy Version: 5.0, 5.1
@author Sean S. LeBlanc, David Mowatt
@description
Adds a (p) tag to the dialogue parser that forces the following text to 
start on a fresh dialogue screen, eliminating the need to spend hours testing
line lengths or adding multiple line breaks that then have to be reviewed
when you make edits or change the font size.
Usage: (p)
       
Example: I am a cat(p)and my dialogue contains multitudes
HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).
NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.
      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/

//Adds the actual dialogue tag. No deferred version is required.
addDialogTag('p', function(environment, parameters, onReturn){
    environment.GetDialogBuffer().AddParagraphBreak();
    onReturn(null);
});
// End of (p) paragraph break mod





// override textbox height
inject$1(/textboxInfo\.height = .+;/,
`Object.defineProperty(textboxInfo, 'height', {
  get() { return textboxInfo.padding_vert + (textboxInfo.padding_vert + relativeFontHeight()) * Math.max(${hackOptions.minRows}, dialogBuffer.CurPage().indexOf(dialogBuffer.CurRow())+Math.sign(dialogBuffer.CurCharCount())) + textboxInfo.arrow_height; }
})`);
// prevent textbox from caching
inject$1(/(if\(textboxInfo\.img == null\))/, '// $1');
// rewrite hard-coded row limit
inject$1(/(else if \(curRowIndex )== 0/g, '$1< ' + hackOptions.maxRows + ' - 1');
inject$1(/(if\( lastPage\.length) <= 1( \) {)/, '$1 < ' + hackOptions.maxRows + ' $2');

exports.hackOptions = hackOptions;

}(this.hacks.long_dialog = this.hacks.long_dialog || {}, window));
</script>